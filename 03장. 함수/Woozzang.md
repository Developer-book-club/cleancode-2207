# 3장 함수

어떤 프로그램이든 가장 기본적인 단위가 함수다.

## 이해하기 어려운 코드

- 추상화 수준이 너무 다양하다
- 코드가 길다
- 이상한 플래그를 확인하고, 이상한 문자열을 사용하며, 이상한 함수를 호출한다.

## 질문

- 의도를 분명하게 표현하는 함수를 어떻게  구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

## 작게 만들어라!

- 함수를 만드는 첫째 규칙은 `작게`다.
- 함수를 만드는 둘째 규칙은 `더 작게`다.

### 블록과 들여쓰기

- if 문 else 문 while 문 등에 들어가는 블록은 한줄이어야 한다.
    - 대신 그 한줄은 함수를 호출하는 코드일 것이다.
    - 중첩 구조가 생길만큼 함수가 커져서는 안된다.
- 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.

## 💦 한 가지만 해라! (충분한 이해가 더 필요)

> *함수는 한가지를 해야한다. 그 한 가지를 잘 해야한다. 그 한가지만을 해야한다.*
> 
- 한 가지가 무엇인가?
    - 추상화 수준이 하나라는 뜻
    - 흠… 아직 뭔말인지 확 와닿지는 않는다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

---

## 💦 함수 당 추상화 수준은 하나로! (충분한 이해가 더 필요)

- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
- 특정 표현이 근본 표현인지 세부사항인지 구분하기 어렵기 떄문이다.
- 근본 개념과 세부 사항을 뒤섞기 시작하면, 꺠어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

### 위에서 아래로 코드 읽기 : 내려가기 규칙

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.

## 🔥 Switch 문

- 작게 만들기 어렵다.
- 본질적으로 switch 문은 N가지를 처리한다.
- 아래는 polymorphism 을 이용하여 저차원 클래스에 각 switch 문을 숨시고 절대로 반복하지 않게 한 코드다.
    - 아래 코드는 몇가지 문제가 있다.
        - 함수가 길다. 새로운 직원 유형이 생기면 더 길어진다.
        - 한 가지 작업만 수행하지 않는다.
        - SRP 를 위반한다. 코드를 변경할 이유가 여럿이다.
        - OCP 를 위반한다. 새 직원 유형을 추가할 때마다 코드를 변경하기 때문이다.
        - 위 함수와 구조가 동일한 함수가 무한정 존재한다는 사실이다.
            - isPayDay(Employee e, Date date);
            - deliverPay(Employee e, Money pay);

```java
public Money caculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) {
		case COMMISIONED:
			return calculateCommisionedPay(e);
		case HOURLY:
			return calculateHourlyPat(e);
		case SALARIED:
			return calculateSalariedPay(e);
		default:
			throw new InvalidEmployeeType(e.type);
	}
}
```

## 서술적인 이름을 사용하라!

- 함수 하는일을 좀더 잘 표현하는 이름을 사용하라!

## 함수인수

- 이상적인 함수 인수 개수는 0개이다
    - 그 다음 1개, 2개… 3개는 피하는 것이 좋다.

## 부수효과를 일으키지 마라!

- 거짓말이다.
    - 함수에서 한가지를 하겠다고 약속하고선 남몰래 다른 짓을 한다.
- 시간적인 결합이 발생한다면 혼란을 일으킨다.
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 취한다.

## 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘중 하나만 해야한다.

## 🔥 오류보다 예외를 사용하라!

- 명령 함수에서 오류 코드를 반환하는 방식은 명령.조회 분리 규칙을 미묘하게 위반한다.
    
    ```java
    if (deletePage(page) == E_OK)..
    ```
    
    위 코드는 동사 . 형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다.
    
    오류코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야한다는 문제에 부딪힌다.
    
- 이때 예외를 사용하면 코드가 깔끔해진다.

### try/catch 블록 뽑아내기 (pg.58)

- 별도 함수로 뽑아내는 편이 좋다.
    
    ```java
    try {
    	deletePage(page);
    	registry.deleteReference(page.name);
    	configKeys.deleteKey(page.name.makeKey());
    }
    catch (Exception e) {
    	logger.log(e.getMessage());
    }
    ```
    

- 위 함수에서 deletePage() 만 throwing method 이므로 뽑아내는 것이 좋다.
    - 나머지 함수는 예외를 처리하지 않는다.
    
    ```java
    public void deletePage(Page page) {
    	try {
    		deletePage(page);
    	}
    	catch (Exception e) {
    		logger.log(e.getMessage());
    	}
    }
    ```
    

- 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.

## 반복하지 마라!

중복은 소프트웨어에서 모든 악의 근원이다.

중복을 없애면 모듈 가독성이 크게 높아진다.

많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.

소프트웨어 개발에서 지금까지 일어난 혁신은 소스코드에서 중복을 제거하려는 지속적인 노력으로 보인다.

## 구조적 프로그래밍

- 함수는 return 문이 하나여야한다?

## 함수를 어떻게 짜죠?

- 소프트웨어를 짜는 행위는 글짓기와 비슷하다.
- 우선 짜고, 단위테스트를 만든다.
- 이후 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
    - 이 와중에도 코드는 항상 단위 테스트를 통과한다.
- 처음부터 탁 짜내지 않는다.

## 결론

- 프로그래밍의 기술은 언제나 언어 설계의 기술이다.
- 함수는 동사이며, 클래스는 명사다.
- 마스터 프로그래머는 시스템을 이야기로 여긴다.
- 진짜 목표는 시스템이라는 이야기를 풀어가는데 있다는 사실을 명심하라.
- 우리가 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 맞아떨어져야 이야기를 풀어가기가 쉬워진다.
