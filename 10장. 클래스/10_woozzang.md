### 

- Single Reponsibility Principle
- 클래스나 모듈을 **변경할 이유가 단 하나 뿐이어야한다는 원칙**이다.
- 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 
쉬워진다.
    - 더 좋은 추상화가 쉽게 떠오른다.
    - 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 
다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.
- SRP 는 객체 지향 설계에서 더욱 중요한 개념이다.
    - 가장 무시되는 규칙 중 하나
    - 수많은 책임을 떠안은 클래스를 꾸준하게 접한다.
    - 왜? 두가지 작업은 별개이기 때문이다.
        - 소프트웨어를 돌아가게 만드는 활동
        - 소프트웨어를 깨끗하게 만드는 활동

<aside>
💡 **큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 
바람직하다.**

- **많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 
이해하기 어려워진다고 우려한다.**
    - 큰 그림을 이해하려면 이 클래스 저 클래스를 수없이 넘나들어야 
한다고 걱정한다.
    - 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 
시스템이든 돌아가는 부품은 그 수가 비슷하다.
- **도구 상자를 어떻게 관리하고 싶은가?**
    - 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 
싶은가?
    - 큰 서랍을 몇개를 두고 모두 던져넣고 싶은가?
- **복잡성을 다루려면 체계적인 정리가 필수다.**
    - 그래야 개발자가 무엇이 어디에 있는지 쉽게 찾는다.
- 큼직한 다목적 클래스 몇개로 이뤄진 시스템은 당장 알 필요가 없는 
사실까지 들이밀어 독자를 방해한다.
</aside>

### - 응집도

- 인스턴스 변수 수
- 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야한다
- 일반적으로
- 응집도가 가장 높은 경우

- 응집도가 높은 클래스를 선호
- 응집도가 높다는 말: 논리적인 단위로 묶인다는 의미
    - 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 
묶인다는 의미다.

### 응집도를 유지하면 작은 클래스 여럿이 나온다

- 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다.
- 어떻게? 예를 들어
    - 변수가 아주 많은 큰 함수 하나가 있다.
    - 큰 함수 일부를 작은 함수 하나로 빼내고 싶은데, 빼내려는 코드가 
큰 함수에 정의된 변수 넷을 사용한다.
    - 이 때, 네 변수를 클래스 인스턴스 변수로 승격한다면 새로 만들 
작은 함수는 인수가 필요 없다.
    - 그만큼 함수를 쪼개기 쉬워진다.
    - 불행히도 이렇게 하면 클래스가 응집력을 잃는다.
        - 몇몇 함수만 사용하는 인스턴스 변수가 점점 더 늘어나기 
때문이다.
    - 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리해도 
되지 않는다?
        - 당연하다. 클래스가 응집력을 잃는다면 쪼개라!
    - 그래서 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 
클래스 여럿으로 쪼갤 기회가 생긴다.

## 변경하기 쉬운 클래스

- 대다수 시스템은 지속적인 변경이 가해진다.
- 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 
따른다.
- 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 
낮춘다.
- SRP
- OCP
    - 확장에 개방적이고 수정에 폐쇄적이어야한다
    - 재구성한 SQL 클래스는 파생클래스를 생성하는 방식으로 새 기능에 
개방적이다.
    - 다른 클래스를 닫아놓는 방식으로 수정에 폐쇄적이다.
- 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 
시스템 구조가 바람직하다.

### 변경으로부터 격리

- 요구사항이 변하면 코드도 변한다.
- 구체적인 클래스와 추상 클래스 (concrete vs. abstract)
    - 구체적인 클래스 : 상세한 구현(코드) 를 포함
